#summary Details on the ScalaCL Compiler Plugin (transforms Scala functions into OpenCL Kernels and optimizes general code)
#labels Featured
<wiki:toc max_depth="3" />

= What is it ? =

The ScalaCL Compiler Plugin makes your code run faster by transforming it at compile-time.

It features general optimizations (not tied to [http://www.khronos.org/opencl/ OpenCL] whatsoever) and [http://www.khronos.org/opencl/ OpenCL]-specific optimizations.

Examples of supported generalist rewrites can be found in the automatic tests :
[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/src/test/scala/scalacl/]

You can also read this thread of the scala-user mailing-list where I announced the plugin :

[http://scala-programming-language.1934581.n4.nabble.com/ScalaCL-Compiler-Plugin-to-optimize-loops-on-arrays-and-int-ranges-out-for-testing-and-feedback-td2953642.html ScalaCL Compiler Plugin to optimize loops on arrays and int ranges (out for testing and feedback)]

== General optimizations ==

The ScalaCL Compiler Plugin optimizes simple generalistic Scala loop-like calls by transforming them into equivalent while loops, which are much faster.

In other terms : *it makes your generalistic Scala code faster for free*.

You don't need [ScalaCLCollections ScalaCL Collections] to benefit from these optimizations and the plugin does not add any dependency to your optimized code (it's just free performance gain, for real :-)).

Here are the methods currently optimized by the plugin (`x` corresponds to the latest stable version, currently `0.1`, while `*` corresponds to the latest development snapshot ; `...` means the case is being investigated and it's not clear if/how things can be optimized):

|| *Method* || *`Array[T]`* || *`List[T]`* || *`Option[T]`* || *inline range <br/>`x to y [by z]` (with filters) * ||
|| `foreach` || x || x ||  || x ||
|| [http://www.scala-lang.org/api/current/scala/Array$.html tabulate] || x ||  ||  ||  ||
|| `map` || x || `*` ||  || `*` ||
|| `reverseMap` ||  ||   ||  ||  ||
|| `sum` || x || x ||  || `*` ||
|| `min` || x || ... ||  ||   ||
|| `max` || x || ... ||  ||  ||
|| `mkString` ||  ||  ||  ||  ||
|| `reduceLeft` || x || ... ||  ||  ||
|| `reduceRight` || x ||  ||  ||  ||
|| `foldLeft` (equiv. to `/:`) || x || x ||  || `*` ||
|| `foldRight` (equiv. to `:/`) || x ||  ||  ||  ||
|| `scanLeft` || x || ... ||  || `*` ||
|| `scanRight` || x ||  ||  ||  ||
|| `forall` || `*` || `*` ||  || `*` ||
|| `exists` || `*` || `*` ||  || `*` ||
|| `count` || `*` || `*`  ||  || `*` ||
|| `prefixLength` ||  ||   ||  ||  ||
|| `partition` ||  ||   ||  ||  ||
|| `span` ||  ||   ||  ||  ||
|| `find` ||  ||  ||  ||  ||
|| `flatMap` ||  ||  ||  ||  ||
|| `filter` || `*` || `*` ||  || `*` ||
|| `filterNot` || `*` || `*` ||  || `*` ||
|| `takeWhile` || `*` || `*` ||  || ... ||
|| `dropWhile` || `*` || `*` ||  || ... ||

== OpenCL-specific optimizations ==

The plugin transforms inline Scala functions in `CLCol.map`, `CLCol.foreach` and `CLCol.filter` into [http://www.khronos.org/opencl/ OpenCL] kernels, effectively running these functions on the GPU via [http://www.khronos.org/opencl/ OpenCL]. 

The programmer must explicitely use [ScalaCLCollections ScalaCL Collections] to use this feature, which is *not yet stable*.

= Using the compiler plugin =

You can use the ScalaCLPlugin with *any of the following options* :

== With scalac (using sbaz) ==

If you're using [http://www.scala-lang.org/docu/files/tools/scalac.html scalac] in command line, the easiest way to test ScalaCL's compiler plugin is to use the following [http://www.scala-lang.org/node/93 sbaz] commands :
{{{
sbaz update
sbaz install scalacl-compiler-plugin
}}}
Then just use `scalac` as you're used to (the plugin will be enabled by default, see below for how to disable it).

Should you wish to uninstall the plugin, run :
{{{
sbaz remove scalacl-compiler-plugin
}}}

To update the plugin :
{{{
sbaz update
sbaz remove scalacl-compiler-plugin
sbaz install scalacl-compiler-plugin
}}}
Or if you don't care upgrading all your sbaz-managed packages :
{{{
sbaz update && sbaz upgrade
}}}

== With sbt (simple-build-tool) ==

To use the ScalaCL Compiler plugin with [http://code.google.com/p/simple-build-tool/ sbt], please make your project file look like this (`project/build/ScalaCLTest.scala`) :
{{{
import sbt._
class ScalaCLTest(info: ProjectInfo) extends DefaultProject(info) with AutoCompilerPlugins
{
  val nativelibs4javaRepo = "NativeLibs4Java Repository" at "http://nativelibs4java.sourceforge.net/maven/"
  val scalacl = compilerPlugin("com.nativelibs4java" % "scalacl-compiler-plugin" % "0.1") // or "1.0-SNAPSHOT" to get the latest development version
}
}}}
Then run this to grab the package (re-run each time you want to update to the latest version of ScalaCL) :
{{{
sbt update
}}}

== With Maven ==

The ScalaCL plugin can be used with [http://maven.apache.org/ Maven], simply edit your `pom.xml` as follows :
{{{
...
  <repositories>
    ...
    <repository>
      <id>nativelibs4java</id>
      <name>nativelibs4java Maven2 Repository</name>
      <url>http://nativelibs4java.sourceforge.net/maven</url>
    </repository>
  </repositories>
  <build>
    ...
    <plugins>
    	<plugin>
          <groupId>org.scala-tools</groupId>
          <artifactId>maven-scala-plugin</artifactId>
          <configuration>
            <compilerPlugins>
              <compilerPlugin>
                <groupId>com.nativelibs4java</groupId>
                <artifactId>scalacl-compiler</artifactId>
                <version>0.1</version>
                <!-- or "1.0-SNAPSHOT" to get the latest development version -->
              </compilerPlugin>
            </compilerPlugins>
          </configuration>
        </plugin>
    </plugins>
  </build>
...
}}}
Maven will automatically update the plugin to the latest available snapshot version each time you run it without the `-o` switch.

== With Eclipse ==

Here's how to configure an [http://www.scala-ide.org/ Eclipse Scala] project so it uses the ScalaCL Compiler Plugin :
  * Download the [http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/0.1/scalacl-compiler-plugin-0.1.jar latest stable version of the ScalaCL Compiler Plugin] (or the [http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/1.0-SNAPSHOT/scalacl-compiler-plugin-1.0-SNAPSHOT.jar latest development version])
  * Open the section "Scala Compiler Properties" of Eclipse project's properties
  * Check "Use Project Settings" to enable the configuration items below
  * Fill the `Xplugin` field with the full path to the JAR you've downloaded, for instance :
{{{
/Users/ochafik/ScalaCLPlugin/target/scalacl-compiler-plugin-xxx.jar
}}}
  * Fill the `Xplugin-require` field with `scalacl` (just in case)
  * Clean your project, so it is rebuilt with the plugin enabled (menu `Project / Clean...`)
In case of issue, it is advised you compile using Maven or scalac+sbaz, because it seems the output from the compiler and from the compiler plugin is not visible from Eclipse.

== Disabling the plugin ==

The plugin is enabled by default. To disable it, set the environment variable DISABLE_SCALACL_PLUGIN to 1 :
{{{
DISABLE_SCALACL_PLUGIN=1 scalac ...
}}}

To disable optimizations for a whole file or at a specific line in a file, use the SCALACL_SKIP environment variable :
{{{
SCALACL_SKIP=file1,file2.scala,../path/to/file3.scala,file4:someLine,file5:someLine...
}}}
(this can be used to troubleshoot the ScalaCL Compiler Plugin : you can narrow compiler crashes down to the faulty line(s))

= Benchmarking =

If you want to compare the performance of Scala programs with and without the ScalaCL Compiler plugin, you can :
  * compile twice the same program : once with the `DISABLE_SCALACL_PLUGIN=1` environment variable set, and once without.
  * put twice the same code in two separate classes and files (`TestWithout.scala` and `TestWith.scala`), then set the `SCALACL_SKIP=TestWithout` environment variable when compiling : the `TestWithout.scala` file won't benefit from any optimization from the compiler plugin.

Also, please think of always using the `-optimise` switch of [http://www.scala-lang.org/docu/files/tools/scalac.html scalac]. You'll notice that it does not reduce the advantage of using the ScalaCL compiler plugin, on the contrary : in many cases the plugin makes it easier for the compiler to optimize the program.

Here's an example of code that gets a x2 to x10 boost with ScalaCL's Compiler Plugin (depending on your JVM settings and on `n`) :
{{{
// Naive dense matrix multiplication
val n = 1000
val a = Array.tabulate(n, n)((i, j) => (i + j) * 1.0)
val b = Array.tabulate(n, n)((i, j) => (i + j) * 1.0)
val o = Array.ofDim[Double](n, n)
for (i <- 0 until n; j <- 0 until n) {
     var tot = 0.0
     for (k <- 0 until n)
         tot += a(i)(k) * b(k)(j)
         
     o(i)(j) = tot
}
}}}
See [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLTest/ some examples of programs] that benefit from being optimized by the ScalaCL Compiler Plugin.

= Status / TODO =

You can [http://twitter.com/#!/ochafik follow news about the ScalaCL plugin on Twitter (@ochafik)].

Pending bugs (please file new ones [http://code.google.com/p/nativelibs4java/issues/list here]) :
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=34 'no-symbol does not have owner' when optimizations take place in a trait] (reported by [http://twitter.com/ijuma @ijuma])~~
  * _OK_ ~~Incorrect int range loops rewrite for negative 'by' values (reported by Rex Kerr)~~
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=32 Inline arrays crash loop optimizer]~~
  * _OK_ ~~Compiler crashes in lambda lift phase with nested loops : `a.map(xx => { a.map(x => { def f = x ; f }) })`~~
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=33 Fails to optimize loops that yield tuples] (`val a = new Array[Int](10); for (i <- a) yield (i, i)`)~~

Important: care was taken so that isolated errors that occur during any optimization skip that optimization and don't prevent the rest of the compilation to succeed (you'll then get output that will invite you to report a bug and to set  the SCALACL_TRACE environment to 1).

General optimizations planned :
  * _OK_ ~~`Array.foreach`~~
  * _OK_ ~~`Array.map`~~
  * _OK_ ~~`for (i <- x to/until y [by z]) body`~~
  * _OK_ ~~`for (i <- x to/until y [by z]; if test) body`~~
  * `for (i <- range [by z][; if test]) body` (will be slower than `for (i <- x to y)` because we need to test Range.isInclusive)
  * _OK_ ~~`Array.tabulate(n)`~~
  * _OK_ ~~`Array.tabulate(n1, n2)`, `Array.tabulate(n1, n2, n3)`...~~
  * `Seq(x, y, z...).foreach -> Array(x, y, z...).foreach` (before the `Array.foreach` transform). Same for `List`
  * _OK_ ~~`Array.reduceLeft` / `reduceRight`~~
  * _OK_ ~~`Array.foldLeft` / `foldRight`~~
  * _OK_ ~~`Array.scanLeft` / `scanRight`~~
  * _OK_ ~~`Array.sum / List.sum`~~
  * _OK_ ~~handle method references (as opposed to inline lambdas)~~
  * _OK_ ~~`List.foreach`~~
  * _OK_ ~~`List.(scan|fold|reduce)Left`~~ (won't write the -Right variants)
  * _OK_ ~~`Array[T]/List[T].min, .max`~~
  * _OK_ ~~`Array[T]/List[T].filter` and `.filterNot`~~
  * `Array[T]/List[T].takeWhile` and `.dropWhile`
  * `Array[T]/List[T].forall, .find` and others methods of the same style
  * map-fuse : `col.map(f).map(g)` becomes `col.map(x => { val fx = f(x); g(fx) })` (avoids one iteration + creation of data structure)
  * filter-fuse `col.filter(f).filter(g)` (avoids one iteration)
  * array filter/map-fuse `array.filter(f).map(g)` and `array.map(f).filter(g)` must be done in one iteration (same as for List)
  Combining the different fuses, one would only execute a single loop for the following statement :
{{{
array.map(f1).filter(f2).map(f3).map(f4).filter(f5).foreach(f6)
}}}
  * use usage- escape-analysis to move constant expressions out of loops (pass to detect expressions that are not aliased for sure, pass to mark side-effect-free code transitively - with dependency graph, each variable node in the graph being versioned -, pass to build timeline of updates and accesses for each var)

Optimizations suggested by thirdparties:
  * [http://twitter.com/#!/retronym/status/26527256634 runtime cases for WrappedArray] (by [http://twitter.com/#!/retronym @retronym])

[ScalaCLCollections ScalaCL Collections] optimizations (not up-to-date, current priority is on general optimizations) :
  * `CLCol.map`, `CLCol.filter` :
    * _OK_ ~~lambda function to OpenCL kernel~~
    * reduceLeft, foldLeft, scanLeft (+ Right), sum...
  * CLArrayView, CLFilteredArrayView
  * escape analysis, reuse of compatible outputs
  * autovectorization
  * auto-ScalaCL-ization

Misc TODO 
  * create more serious benchmarks :
    * [http://www.ibm.com/developerworks/library/j-jtp12214/]
    * [http://blog.juma.me.uk/2009/10/26/new-jvm-options-and-scala-iteration-performance/]

= Compiling Scala with ScalaCL =

ScalaCL is now capable of optimizing Scala + Scalac (versions 2.8.x). Please note however that this does not seem to speed up Scala(c) at all, as little optimizations are done (about 200 in the whole Scala source tree). Next versions (including the latest development version) perform far more optimizations, but please be patient until they're stable enough :-)
{{{
svn co http://lampsvn.epfl.ch/svn-repos/scala/scala/branches/2.8.x scala-2.8.x
cd scala-2.8.x
mkdir -p misc/scala-devel/plugins/
cd misc/scala-devel/plugins/
wget http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/0.1/scalacl-compiler-plugin-0.1.jar
# Or the latest development version :
# wget http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/1.0-SNAPSHOT/scalacl-compiler-plugin-1.0-SNAPSHOT.jar
cd ../../..
ant clean build
}}}
Then you can run tests :
{{{
ANT_OPTS="-Xmx2g -Xms1g -XX:MaxPermSize=500m" ant test
}}}
And to recompile without any optimization :
{{{
DISABLE_SCALACL_PLUGIN=1 ant clean build
}}}

= Where is the source code ? =

[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/LICENSE ScalaCL is licensed under a 3-clause BSD-style license], so it can be integrated in pretty much all living software (including proprietary and (L)GPL).

  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/ ScalaCL Compiler Plugin]
  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCL2/ ScalaCL Collections]

To start hacking on the compiler plugin :
{{{
svn co http://nativelibs4java.googlecode.com/svn/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin
cd ScalaCLPlugin
mvn package
}}}
Also see [CompileScalaCL this page] for how to compile [ScalaCLCollections ScalaCL Collections] as well.