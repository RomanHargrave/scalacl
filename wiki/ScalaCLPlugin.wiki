#summary Details on the ScalaCL Compiler Plugin (transforms Scala functions into OpenCL Kernels and optimizes general code)
#labels Featured
<wiki:toc max_depth="3" />

= What is it ? =

The ScalaCL Compiler Plugin transforms Scala functions in `CLCol.map`, `CLCol.foreach` and `CLCol.filter` into OpenCL kernels (effectively running these functions on the GPU via OpenCL).

It also optimizes simple int-range foreach loops and `Array[T]` or `List[T]`'s `.foreach`, `.map` (only for `Array[T]`), `.reduceLeft`, `.foldLeft`, `.scanLeft` calls (and -Right variants for `Array[T]`) by transforming them into equivalent while loops, which are much faster. 

Examples of supported generalist rewrites can be found in the automatic tests :
[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/src/test/scala/scalacl/]

You can also read this thread of the scala-user mailing-list where I announced the plugin :

[http://scala-programming-language.1934581.n4.nabble.com/ScalaCL-Compiler-Plugin-to-optimize-loops-on-arrays-and-int-ranges-out-for-testing-and-feedback-td2953642.html ScalaCL Compiler Plugin to optimize loops on arrays and int ranges (out for testing and feedback)]

= Where is the source code ? =

[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/LICENSE ScalaCL is licensed under a 3-clause BSD-style license], so it can be integrated in pretty much all living software (including proprietary and (L)GPL).

  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCL2/ ScalaCL Collections]
  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/ ScalaCL Compiler Plugin]

To start hacking on the compiler plugin :
{{{
svn co http://nativelibs4java.googlecode.com/svn/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin
cd ScalaCLPlugin
sbt package
}}}

= Using the plugin =

You can use the ScalaCLPlugin with *any of the following options* :
  * install it using [http://www.scala-lang.org/node/93 sbaz] (this is the easiest way to test ScalaCL's compiler plugin if you're not using Maven or Sbt) :
{{{
sbaz update
sbaz install scalacl-compiler-plugin
}}}
  Then just use `scalac` as you're used to (the plugin will be enabled by default, see below for how to disable it.
  Should you wish to uninstall the plugin, type :
{{{
sbaz remove scalacl-compiler-plugin
}}}
  * use it with [http://code.google.com/p/simple-build-tool/ sbt] :
{{{
import sbt._
class ScalaCLTest(info: ProjectInfo) extends DefaultProject(info) with AutoCompilerPlugins
{
  val nativelibs4javaRepo = "NativeLibs4Java Repository" at "http://nativelibs4java.sourceforge.net/maven/"
  val scalacl = compilerPlugin("com.nativelibs4java" % "scalacl-compiler-plugin" % "1.0-SNAPSHOT")
}
}}}
  * use it with [http://maven.apache.org/ Maven] :
{{{
...
  <repositories>
    ...
    <repository>
      <id>nativelibs4java</id>
      <name>nativelibs4java Maven2 Repository</name>
      <url>http://nativelibs4java.sourceforge.net/maven</url>
    </repository>
  </repositories>
  <build>
    ...
    <plugins>
    	<plugin>
          <groupId>org.scala-tools</groupId>
          <artifactId>maven-scala-plugin</artifactId>
          <configuration>
            <compilerPlugins>
              <compilerPlugin>
                <groupId>com.nativelibs4java</groupId>
                <artifactId>scalacl-compiler</artifactId>
                <version>1.0-SNAPSHOT</version>
              </compilerPlugin>
            </compilerPlugins>
          </configuration>
        </plugin>
    </plugins>
  </build>
...
}}}
  * use it with the [http://www.scala-ide.org/ Eclipse Scala Plugin] :
    * Download the [http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/1.0-SNAPSHOT/scalacl-compiler-plugin-1.0-SNAPSHOT.jar latest version of the ScalaCL Compiler Plugin]
    * Open the section "Scala Compiler Properties" of Eclipse project's properties
    * Check "Use Project Settings" to enable the configuration items below
    * Fill the `Xplugin` field with the full path to the JAR you've downloaded, for instance :
{{{
/Users/ochafik/ScalaCLPlugin/target/scalacl-compiler-plugin-1.0-SNAPSHOT.jar
}}}
    * Fill the `Xplugin-require` field with `scalacl` (just in case)
    * Clean your project, so it is rebuilt with the plugin enabled
  In case of issue, it is advised you compile using Maven or scalac+sbaz, because it seems the output from the compiler and from the compiler plugin is not visible from Eclipse.

The plugin is enabled by default. To disable it, set the environment variable DISABLE_SCALACL_PLUGIN to 1 :
{{{
DISABLE_SCALACL_PLUGIN=1 scalac ...
}}}

To disable optimizations for a whole file or at a specific line in a file, use the SCALACL_SKIP environment variable :
{{{
SCALACL_SKIP=file1,file2.scala,../path/to/file3.scala,file4:someLine,file5:someLine...
}}}
(this can be used to troubleshoot the ScalaCL Compiler Plugin : you can narrow compiler crashes down to the faulty line(s))

= Status / TODO =

Pending bugs :
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=32 Inline arrays crash loop optimizer]~~
  * Fails to optimize loops that yield tuples : `val a = new Array[Int](10); for (i <- a) yield (i, i)` (reported by [http://twitter.com/#!/ijuma @ijuma])

General optimizations planned :
  * _OK_ ~~`Array.foreach`~~
  * _OK_ ~~`Array.map`~~
  * _OK_ ~~`for (i <- x to/until y [by z]) body`~~
  * _OK_ ~~`for (i <- x to/until y [by z]; if test) body`~~
  * `for (i <- range [by z][; if test]) body` (will be slower than `for (i <- x to y)` because we need to test Range.isInclusive)
  * _OK_ ~~`Array.tabulate(n)`~~
  * `Array.tabulate(n1, n2)`, `Array.tabulate(n1, n2, n3)`...
  * `Seq(x, y, z...).foreach -> Array(x, y, z...).foreach` (before the `Array.foreach` transform). Same for `List`
  * _OK_ ~~`Array.reduceLeft` / `reduceRight`~~
  * _OK_ ~~`Array.foldLeft` / `foldRight`~~
  * _OK_ ~~`Array.scanLeft` / `scanRight`~~
  * _OK_ ~~handle method references (as opposed to inline lambdas)~~
  * _OK_ ~~`List.foreach`~~
  * _OK_ ~~`List.(scan|fold|reduce)Left`~~ (won't write the -Right variants)
  * map-fuse : `col.map(f).map(g)` becomes `col.map(x => { val fx = f(x); g(fx) })` (avoids one iteration + creation of data structure)
  * filter-fuse `col.filter(f).filter(g)` (avoids one iteration)
  * `Array.filter` (what kind of output buffer should we use ?)
  * array filter/map-fuse `array.filter(f).map(g)` and `array.map(f).filter(g)` must be done in one iteration (same as for List)

Optimizations suggested by thirdparties:
  * [http://twitter.com/#!/retronym/status/26527256634 runtime cases for WrappedArray] (by [http://twitter.com/#!/retronym @retronym])

OpenCL optimizations (not up-to-date, current priority is on general optimizations) :
  * CLCol.map, CLCol.filter :
    * _OK_ ~~lambda function to OpenCL kernel~~
    * reduceLeft, foldLeft, scanLeft (+ Right), sum...
  * CLArrayView, CLFilteredArrayView
  * escape analysis, reuse of compatible outputs
  * autovectorization
  * auto-ScalaCL-ization

Misc TODO 
  * create more serious benchmarks :
    * [http://www.ibm.com/developerworks/library/j-jtp12214/]
    * [http://blog.juma.me.uk/2009/10/26/new-jvm-options-and-scala-iteration-performance/]