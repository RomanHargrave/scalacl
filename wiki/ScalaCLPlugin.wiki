#summary Details on the ScalaCL Compiler Plugin (transforms Scala functions into OpenCL Kernels and optimizes general code)
#labels Featured
<wiki:toc max_depth="3" />

= What is it ? =

The ScalaCL Compiler Plugin transforms Scala functions in `CLCol.map`, `CLCol.foreach` and `CLCol.filter` into OpenCL kernels (effectively running these functions on the GPU via OpenCL).

It also optimizes simple int-range foreach loops and `Array[T].foreach`, `.map`, `.reduceLeft`, `.foldLeft`, `.scanLeft` calls (and -Right variants) by transforming them into equivalent while loops, which are much faster). 

Examples of supported generalist rewrites can be found in the automatic tests :
[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/src/test/scala/scalacl/]

You can also read this thread of the scala-user mailing-list where I announced the plugin :

[http://scala-programming-language.1934581.n4.nabble.com/ScalaCL-Compiler-Plugin-to-optimize-loops-on-arrays-and-int-ranges-out-for-testing-and-feedback-td2953642.html ScalaCL Compiler Plugin to optimize loops on arrays and int ranges (out for testing and feedback)]

= Where is the source code ? =

[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/LICENSE ScalaCL is licensed under a 3-clause BSD-style license], so it can be integrated in pretty much all living software (including proprietary and (L)GPL).

  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCL2/ ScalaCL Collections]
  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/ ScalaCL Compiler Plugin]

To start hacking on the compiler plugin :
{{{
svn co http://nativelibs4java.googlecode.com/svn/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin
cd ScalaCLPlugin
sbt package
}}}

= Using the plugin =

You can use the ScalaCLPlugin with *any of the following options* :
  * use it with [http://code.google.com/p/simple-build-tool/ sbt] :
{{{
import sbt._
class ScalaCLTest(info: ProjectInfo) extends DefaultProject(info) with AutoCompilerPlugins
{
  val nativelibs4javaRepo = "NativeLibs4Java Repository" at "http://nativelibs4java.sourceforge.net/maven/"
  val scalacl = compilerPlugin("com.nativelibs4java" % "scalacl-compiler-plugin" % "1.0-SNAPSHOT")
}
}}}
  * use it with [http://maven.apache.org/ Maven] :
{{{
...
  <repositories>
    ...
    <repository>
      <id>nativelibs4java</id>
      <name>nativelibs4java Maven2 Repository</name>
      <url>http://nativelibs4java.sourceforge.net/maven</url>
    </repository>
  </repositories>
  <build>
    ...
    <plugins>
    	<plugin>
          <groupId>org.scala-tools</groupId>
          <artifactId>maven-scala-plugin</artifactId>
          <configuration>
            <compilerPlugins>
              <compilerPlugin>
                <groupId>com.nativelibs4java</groupId>
                <artifactId>scalacl-compiler</artifactId>
                <version>1.0-SNAPSHOT</version>
              </compilerPlugin>
            </compilerPlugins>
          </configuration>
        </plugin>
    </plugins>
  </build>
...
}}}
  * install it using [http://www.scala-lang.org/node/93 sbaz] :
{{{
sbaz update
sbaz install scalacl-compiler-plugin
}}}

The plugin is enabled by default. To disable it, set the environment variable DISABLE_SCALACL_PLUGIN to 1 :
{{{
DISABLE_SCALACL_PLUGIN=1 scalac ...
}}}

= Status / TODO =

Pending bugs :
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=32 Inline arrays crash loop optimizer]~~

General optimizations
  * _OK_ ~~`Array.foreach`~~
  * _OK_ ~~`Array.map`~~
  * _OK_ ~~`for (i <- x to/until y [by z]) body`~~
  * _OK_ ~~`for (i <- x to/until y [by z]; if test) body`~~
  * `for (i <- range [by z][; if test]) body` (will be slower than `for (i <- x to y)` because we need to test Range.isInclusive)
  * `Array.tabulate`
  * `Seq(x, y, z...).foreach -> Array(x, y, z...).foreach` (before the `Array.foreach` transform). Same for `List`
  * _OK_ ~~`Array.reduceLeft` / reduceRight~~
  * _OK_ ~~`Array.foldLeft` / foldRight~~
  * _OK_ ~~`Array.scanLeft` / scanRight~~
  * _OK_ ~~handle method references (as opposed to inline lambdas)~~
  * `List.foreach` and all associated methods (while loops appear to be faster !!!)
  * `col.map(f).map(g)` : `col.map(g(f(_)))`
  * `col.filter(f).filter(g)`

Optimizations suggested by thirdparties:
  * [http://twitter.com/#!/retronym/status/26527256634 runtime cases for WrappedArray] (by [http://twitter.com/#!/retronym @retronym])

OpenCL optimizations (not up-to-date, current priority is on general optimizations)
  * CLCol.map, CLCol.filter :
    * _OK_ ~~lambda function to OpenCL kernel~~
    * reduceLeft, foldLeft, scanLeft (+ Right), sum...
  * CLArrayView, CLFilteredArrayView
  * escape analysis, reuse of compatible outputs
  * autovectorization
  * auto-ScalaCL-ization