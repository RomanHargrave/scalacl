#summary Details on the ScalaCL Compiler Plugin (transforms Scala functions into OpenCL Kernels and optimizes general code)
#labels Featured
<wiki:toc max_depth="3" />

= What is it ? =

The ScalaCL Compiler Plugin makes your code run faster by transforming it at compile-time.

It features general optimizations (not tied to [http://www.khronos.org/opencl/ OpenCL] whatsoever) and [http://www.khronos.org/opencl/ OpenCL]-specific optimizations.

Examples of supported generalist rewrites can be found in the automatic tests :
[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/src/test/scala/scalacl/]

You can also read this thread of the scala-user mailing-list where I announced the plugin :

[http://scala-programming-language.1934581.n4.nabble.com/ScalaCL-Compiler-Plugin-to-optimize-loops-on-arrays-and-int-ranges-out-for-testing-and-feedback-td2953642.html ScalaCL Compiler Plugin to optimize loops on arrays and int ranges (out for testing and feedback)]

== General optimizations ==

The ScalaCL Compiler Plugin optimizes simple generalistic Scala loop-like calls by transforming them into equivalent while loops, which are much faster.

In other terms : *it makes your generalistic Scala code faster for free*.

You don't need [ScalaCLCollections ScalaCL Collections] to benefit from these optimizations and the plugin does not add any dependency to your optimized code (it's just free performance gain, for real :-)).

Here are the methods currently optimized by the plugin (`x` corresponds to the latest stable version, currently `0.1`, while `*` corresponds to the latest development snapshot ; `...` means the case is being investigated and it's not clear if/how things can be optimized):

|| *Method* || *`Array[T]`* || *`List[T]`* || *`Option[T]`* || *inline range <br/>`x to y [by z]` (with filters) * ||
|| `foreach` || x || x ||  || x ||
|| [http://www.scala-lang.org/api/current/scala/Array$.html tabulate] || x ||  ||  ||  ||
|| `map` || x || `*` ||  || `*` ||
|| `reverseMap` ||  ||   ||  ||  ||
|| `sum` || x || x ||  || `*` ||
|| `min` || x || `*` ||  ||   ||
|| `max` || x || `*` ||  ||  ||
|| `mkString` ||  ||  ||  ||  ||
|| `reduceLeft` || x || `*` ||  ||  ||
|| `reduceRight` || x ||  ||  ||  ||
|| `foldLeft` (equiv. to `/:`) || x || x ||  || `*` ||
|| `foldRight` (equiv. to `:/`) || x ||  ||  ||  ||
|| `scanLeft` || x || `*` ||  || `*` ||
|| `scanRight` || x ||  ||  ||  ||
|| `forall` || `*` || `*` ||  || `*` ||
|| `exists` || `*` || `*` ||  || `*` ||
|| `count` || `*` || `*`  ||  || `*` ||
|| `prefixLength` ||  ||   ||  ||  ||
|| `partition` ||  ||   ||  ||  ||
|| `span` ||  ||   ||  ||  ||
|| `find` ||  ||  ||  ||  ||
|| `flatMap` ||  ||  ||  ||  ||
|| `filter` || `*` || `*` ||  || `*` ||
|| `filterNot` || `*` || `*` ||  || `*` ||
|| `prefixLength` ||  ||  ||  ||  ||
|| `indexWhere` ||  ||  ||  ||  ||
|| `lastIndexWhere` ||  ||  ||  ||  ||
|| `takeWhile` || `*` || `*` ||  || ... ||
|| `dropWhile` || `*` || `*` ||  || ... ||

== OpenCL-specific optimizations ==

The plugin transforms inline Scala functions in `CLCollection.map` and `CLCollection.filter` into [http://www.khronos.org/opencl/ OpenCL] kernels, effectively running these functions on the GPU via [http://www.khronos.org/opencl/ OpenCL]. 

The programmer must explicitely use [ScalaCLCollections ScalaCL Collections] to use this feature, which is *not yet stable*.

= Using the compiler plugin =

Please see the [Usage] page.

= Benchmarking =

If you want to compare the performance of Scala programs with and without the ScalaCL Compiler plugin, you can :
  * compile twice the same program : once with the `DISABLE_SCALACL_PLUGIN=1` environment variable set, and once without.
  * put twice the same code in two separate classes and files (`TestWithout.scala` and `TestWith.scala`), then set the `SCALACL_SKIP=TestWithout` environment variable when compiling : the `TestWithout.scala` file won't benefit from any optimization from the compiler plugin.

Also, please think of always using the `-optimise` switch of [http://www.scala-lang.org/docu/files/tools/scalac.html scalac]. You'll notice that it does not reduce the advantage of using the ScalaCL compiler plugin, on the contrary : in many cases the plugin makes it easier for the compiler to optimize the program.

Here's an example of code that gets a x2 to x10 boost with ScalaCL's Compiler Plugin (depending on your JVM settings and on `n`) :
{{{
// Naive dense matrix multiplication
val n = 1000
val a = Array.tabulate(n, n)((i, j) => (i + j) * 1.0)
val b = Array.tabulate(n, n)((i, j) => (i + j) * 1.0)
val o = Array.ofDim[Double](n, n)
for (i <- 0 until n; j <- 0 until n) {
     var tot = 0.0
     for (k <- 0 until n)
         tot += a(i)(k) * b(k)(j)
         
     o(i)(j) = tot
}
}}}
See [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLTest/ some examples of programs] that benefit from being optimized by the ScalaCL Compiler Plugin.

= Project = 

You can [http://twitter.com/#!/ochafik follow news about the ScalaCL plugin on Twitter (@ochafik)].

== TODO ==

Pending bugs (please file new ones [http://code.google.com/p/nativelibs4java/issues/list here]) :
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=34 'no-symbol does not have owner' when optimizations take place in a trait] (reported by [http://twitter.com/ijuma @ijuma])~~
  * _OK_ ~~Incorrect int range loops rewrite for negative 'by' values (reported by Rex Kerr)~~
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=32 Inline arrays crash loop optimizer]~~
  * _OK_ ~~Compiler crashes in lambda lift phase with nested loops : `a.map(xx => { a.map(x => { def f = x ; f }) })`~~
  * _OK_ ~~[http://code.google.com/p/nativelibs4java/issues/detail?id=33 Fails to optimize loops that yield tuples] (`val a = new Array[Int](10); for (i <- a) yield (i, i)`)~~

Important: care was taken so that isolated errors that occur during any optimization skip that optimization and don't prevent the rest of the compilation to succeed (you'll then get output that will invite you to report a bug and to set  the SCALACL_TRACE environment to 1).

General optimizations planned :
  * _OK_ ~~`Array.foreach`~~
  * _OK_ ~~`Array.map`~~
  * _OK_ ~~`for (i <- x to/until y [by z]) body`~~
  * _OK_ ~~`for (i <- x to/until y [by z]; if test) body`~~
  * `for (i <- range [by z][; if test]) body` (will be slower than `for (i <- x to y)` because we need to test Range.isInclusive)
  * _OK_ ~~`Array.tabulate(n)`~~
  * _OK_ ~~`Array.tabulate(n1, n2)`, `Array.tabulate(n1, n2, n3)`...~~
  * `Seq(x, y, z...).foreach -> Array(x, y, z...).foreach` (before the `Array.foreach` transform). Same for `List`
  * _OK_ ~~`Array.reduceLeft` / `reduceRight`~~
  * _OK_ ~~`Array.foldLeft` / `foldRight`~~
  * _OK_ ~~`Array.scanLeft` / `scanRight`~~
  * _OK_ ~~`Array.sum / List.sum`~~
  * _OK_ ~~handle method references (as opposed to inline lambdas)~~
  * _OK_ ~~`List.foreach`~~
  * _OK_ ~~`List.(scan|fold|reduce)Left`~~ (won't write the -Right variants)
  * _OK_ ~~`Array[T]/List[T].min, .max`~~
  * _OK_ ~~`Array[T]/List[T].filter` and `.filterNot`~~
  * `Array[T]/List[T].takeWhile` and `.dropWhile`
  * `Array[T]/List[T].forall, .find` and others methods of the same style
  * map-fuse : `col.map(f).map(g)` becomes `col.map(x => { val fx = f(x); g(fx) })` (avoids one iteration + creation of data structure)
  * filter-fuse `col.filter(f).filter(g)` (avoids one iteration)
  * array filter/map-fuse `array.filter(f).map(g)` and `array.map(f).filter(g)` must be done in one iteration (same as for List)
  Combining the different fuses, one would only execute a single loop for the following statement :
{{{
array.map(f1).filter(f2).map(f3).map(f4).filter(f5).foreach(f6)
}}}
  * use usage- escape-analysis to move constant expressions out of loops (pass to detect expressions that are not aliased for sure, pass to mark side-effect-free code transitively - with dependency graph, each variable node in the graph being versioned -, pass to build timeline of updates and accesses for each var)

Optimizations suggested by thirdparties:
  * [http://twitter.com/#!/retronym/status/26527256634 runtime cases for WrappedArray] (by [http://twitter.com/#!/retronym @retronym])

[ScalaCLCollections ScalaCL Collections] optimizations (not up-to-date, current priority is on general optimizations) :
  * `CLCol.map`, `CLCol.filter` :
    * _OK_ ~~lambda function to OpenCL kernel~~
    * reduceLeft, foldLeft, scanLeft (+ Right), sum...
  * CLArrayView, CLFilteredArrayView
  * escape analysis, reuse of compatible outputs
  * autovectorization
  * auto-ScalaCL-ization

Misc TODO 
  * create more serious benchmarks :
    * [http://www.ibm.com/developerworks/library/j-jtp12214/]
    * [http://blog.juma.me.uk/2009/10/26/new-jvm-options-and-scala-iteration-performance/]

== Compiling Scala with ScalaCL ==

ScalaCL is now capable of optimizing Scala + Scalac (versions 2.8.x). Please note however that this does not seem to speed up Scala(c) at all, as little optimizations are done (about 200 in the whole Scala source tree). Next versions (including the latest development version) perform far more optimizations, but please be patient until they're stable enough :-)
{{{
svn co http://lampsvn.epfl.ch/svn-repos/scala/scala/branches/2.8.x scala-2.8.x
cd scala-2.8.x
mkdir -p misc/scala-devel/plugins/
cd misc/scala-devel/plugins/
wget http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/0.1/scalacl-compiler-plugin-0.1.jar
# Or the latest development version :
# wget http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/scalacl-compiler-plugin/1.0-SNAPSHOT/scalacl-compiler-plugin-1.0-SNAPSHOT.jar
cd ../../..
ant clean build
}}}
Then you can run tests :
{{{
ANT_OPTS="-Xmx2g -Xms1g -XX:MaxPermSize=500m" ant test
}}}
And to recompile without any optimization :
{{{
DISABLE_SCALACL_PLUGIN=1 ant clean build
}}}

== Where is the source code ? ==

[http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/LICENSE ScalaCL is licensed under a 3-clause BSD-style license], so it can be integrated in pretty much all living software (including proprietary and (L)GPL).

  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin/ ScalaCL Compiler Plugin]
  * [http://code.google.com/p/nativelibs4java/source/browse/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCL2/ ScalaCL Collections]

To start hacking on the compiler plugin :
{{{
svn co http://nativelibs4java.googlecode.com/svn/branches/OpenCL-BridJ/libraries/OpenCL/ScalaCLPlugin
cd ScalaCLPlugin
mvn package
}}}
Also see [CompileScalaCL this page] for how to compile [ScalaCLCollections ScalaCL Collections] as well.

== Automated Tests ==

Most tests are run with :
{{{
mvn test
}}}

However, the PerformanceTest is much slower and is disabled by default (it does a microbenchmark for nearly all the optimized cases, with varying collection sizes, cold vs. warm tests, optimized vs. non-optimized comparison...) :
{{{
SCALACL_TEST_PERF=1 mvn test -Dtest=PerformanceTest
}}}