#summary Details on which Scala constructs can be converted to OpenCL kernels
#sidebar TOCWiki
<wiki:toc max_depth="3" />

Scala offers nice and varied syntactic constructs. Not all of them translate easily to C / OpenCL, so we had to pick the easiest + most useful.

For now, we're focusing on tuples (access, creation and case-matching), for/while loops (or anything that can be converted to a while loop by [ScalaCLPlugin ScalaCL's compiler plugin]) and external val capture.

= Important note : (not) everything is supported =

Strictly speaking, all possible valid Scala constructs should _work_ with [ScalaCLCollections ScalaCL collections] : your code will run and will produce correct results, but the code might be slow as hell : when a function is not OpenCL-enabled (which is done by the [ScalaCLPlugin compiler plugin]), ScalaCL runs it in the Scala/Java land. The problem is that the data of [ScalaCLCollections ScalaCL collections] is stored in the OpenCL land (e.g. on the GPU), so it has to be copied over to Java and probably back to OpenCL.

To make sure you're actually executing your `map` and `filter` operations in OpenCL-mode, you can set the `SCALACL_VERBOSE` environment variable to `1` (see [FAQ]).

You can also disable the execution of OpenCL kernels by setting the environment variable `SCALACL_USE_SCALA_FUNCTION` to `1`, which will force all functions to be executed in Scala/Java land.

= Constructs currently supported =

The following constructs are supported in the latest development version of ScalaCL, typically available on sbaz (see [Usage] for how to install / use it).

Right now you can use `scala.math` functions (the ones that have [http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/mathFunctions.html direct OpenCL counterparts]), use tuples, create tuples in final values, declare vars and use simple if valued statements (without blocks) :
{{{
import scalacl._
import scala.math._

implicit val context = new ScalaCLContext

val a = // CLArray[Int]
  (1000 to 100000).toCLArray

// Filter :
val f = 
  a.filter(v => (v % 2) != 0)
println(f)

// Map to / from tuples, zip(WithIndex) :
val r = // CLIndexedSeq[(Float, Int)]
  a.zip(a.map(_ * 2f)).zipWithIndex.map(t => {
    val ((a, b), i) = t
    (exp(a).toFloat + b + i, a)
  })
println(r)

// Simple if expressions
val r2 = 
  a.map(v => if (v < 0) v * 20 else v - 4)
println(r2)
}}}

Doesn't work for you ? Please [Issues report it] !

= Constructs planned to be supported in next ScalaCL release (0.2) =

The translation engine is being rewritten to allow a much broader set of constructs :
{{{
import scalacl._
import scala.math._

implicit val context = new ScalaCLContext

val a: CLArray[Int] = 
  (1000 to 100000).toCLArray

// Case-matching of tuples :
val r: CLIndexedSeq[(Float, Int)] = 
  a.zip(a.map(_ * 2f)).zipWithIndex.map { case ((a, b), i) => (exp(a).toFloat + b + i, a) }

// Rich statements with blocks, filtered loops (at least on inline ranges) :
val extVal = 10
val r2: CLIndexedSeq[(Int, Int)] = 
  arr.map(v => {

    def someFun(x: Int) = // becomes a top-level function inside the OpenCL kernel
      exp(x / 1000).toInt

    var pair @ (sum, foo) = { // tuples will be flattened in the OpenCL kernel
       val d = v - extVal     // unless they match an OpenCL tuple type like int2
       (d * d, 1 / d)
    }
    for (i <- 0 until extVal; if (i % 2) != 0) {
       sum += cos(v) * i + someFun(pair._2 - foo)
    }
    (sum, foo)
  })
}}}

= Constructs maybe supported later =

{{{
{
  def swallowedFromOutside(x: Int) = x + 1
  CLArray(1, 2, 3).map(v => (v, swallowedFromOutside(v))) // function is "swallowed" inside converted OpenCL function
  
  CLArray(1, 2, 3).map(v => {
    def inside(x: Int) = x + 1 
    (v, inside(v))
  })
}}}

Have suggestions on something easy and useful to support ? Please [Issues request it] !