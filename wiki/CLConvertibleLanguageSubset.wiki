#summary Details on which Scala constructs can be converted to OpenCL kernels
#sidebar TOCWiki
<wiki:toc max_depth="3" />

Scala offers nice and varied syntactic constructs. Not all of them translate easily to C / OpenCL, so we had to pick the easiest + most useful.

For now, we're focusing on tuples (access, creation and case-matching), for/while loops (or anything that can be converted to a while loop by [ScalaCLPlugin ScalaCL's compiler plugin]) and external val capture.

= Important note : (not) everything is supported =

Strictly speaking, all possible valid Scala constructs should _work_ with ScalaCL : your code will run and will produce correct results, but the code might be slow as hell : when a function is not OpenCL-enabled (which is done by the [ScalaCLPlugin compiler plugin]), ScalaCL runs it in the Scala/Java land. The problem is that the data of [ScalaCLCollections ScalaCL collections] is stored in the OpenCL land (e.g. on the GPU), so it has to be copied over to Java and probably back to OpenCL.

To make sure you're actually executing your `map` and `filter` operations in OpenCL-mode, you can set the `SCALACL_VERBOSE` environment variable to `1` (see [FAQ]).

= Constructs currently supported =

The following constructs are supported in the latest development version of ScalaCL, `0.2-SNAPSHOT` (see [Usage] for how to use it).

Right now you can use `scala.math` functions, use tuples, create tuples in final values, declare vars and use simple if valued statements (without blocks) :
{{{
import scala.math._

val a: CLArray[Int] = 
  (1000 to 100000).toCLArray

// Filter :
val f = a.filter(v => (v % 2) != 0)

// Map to / from tuples, zip(WithIndex) :
val r: CLIndexedSeq[(Float, Int)] = 
  a.zip(a.map(_ * 2f)).zipWithIndex.map(t => {
    // t is a ((Int, Float), Int)
    val a = t._1._1
    val b = t._1._2
    val i = t._2
    (exp(a).toFloat + b + i, a)
  })

// Simple if expressions
val r2 = a.map(v => if (v < 0) v * 20 else v - 4)
}}}

= Constructs planned to be supported in next ScalaCL release (0.2) =

The translation engine is being rewritten to allow a much broader set of constructs :
{{{
import scala.math._

val a: CLArray[Int] = 
  (1000 to 100000).toCLArray

// Case-matching of tuples :
val r: CLIndexedSeq[(Float, Int)] = 
  a.zip(a.map(_ * 2f)).zipWithIndex.map { case ((a, b), i) => (exp(a).toFloat + b + i, a) }

// Rich statements with blocks, filtered loops (at least on inline ranges) :
val extVal = 10
val r2 = arr.map(v => {
  var sum = { 
     val d = v - extVal 
     d * d
  }
  for (i <- 0 until extVal; if (i % 2) != 0) {
     sum += cos(v) * i
  }
  sum
})
}}}

= Constructs maybe supported later =

{{{
{
  def swallowedFromOutside(x: Int) = x + 1
  CLArray(1, 2, 3).map(v => (v, swallowedFromOutside(v))) // function is "swallowed" inside converted OpenCL function
  
  CLArray(1, 2, 3).map(v => {
    def inside(x: Int) = x + 1 // function is made an independent top-level function inside the OpenCL kernel
    (v, inside(v))
  })
}}}
...