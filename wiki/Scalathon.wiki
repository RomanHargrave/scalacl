#summary How and what to hack ScalaCL during the Scalathon 2011 hacking session
<wiki:toc max_depth="3" />

= Documentation =

  * Olivier Chafik's [http://scalacl.googlecode.com/svn/wiki/ScalaCL%20Scalathon%20Philadelphia%202011.pdf ScalaCL slides from Scalathon's speech] 
  * Mirko Stocker's [http://scala-refactoring.org/wp-content/uploads/scala-refactoring.pdf Scala Refactoring] master's thesis contains lots of easy to understand documentation about the compiler's AST in its Appendix D.
  * anything missing ? come and ask !

= Cheat sheet =

== Scalac options ==

{{{
scalac -Xprint:typer test.scala
}}}


{{{
scalac -Xprint:typer -Yshow-trees test.scala
}}}

{{{
scalac -Ybrowse:typer test.scala
}}}

You can replace `typer` by any other phase, such as `scalacl-loopstransform`.

== Run the compiler with the plugin ==

{{{
export SCALACL_TRACE=1
export SCALACL_VERBOSE=1

mvn scala:run -DmainClass=scalacl.plugin.Compile "-DaddArgs=Test.scala|-Xprint:scalacl-loopstransform|../ScalaCL/target/scalacl-0.3-SNAPSHOT-shaded.jar"
}}}

== Workflow ==

  * Use sbt to ~compile your code as you write it
  * Use maven to run tests (or help fix scalacl's tests with sbt 0.10.1 :-))
  * Use maven to run (or help fix scalacl + sbt run : scalacl.plugin.Compile does not seem to run fine in sbt :-S)

= What can you hack ? =

  * moving code generation from runtime library to compiler plugin : look for `println("sourceData = " + sourceData)` in `ScalaCLFunctionsTransformComponent.scala`, and for `CLFunction`'s constructor : constructor needs to be modified to take the actual OpenCL code, rather than the normalized code's intermediate form
  * implementing the new design of loops rewriting : look for `StreamOps.scala` vs. `TraversalOps.scala` vs. `LoopsTransformComponent.scala`
  * side-effects detection (still completely broken) : see code in `CodeAnalysis.scala`
  * symmetry detection : copy paste code from side-effects detection and get going :-)
  * sbt migration : 
    * `sbt test` fails, `mvn test` succeeds (except for side effects tests)
    * use a separate `URLClassLoader` to override the `scala-compiler.jar` used to run the code... otherwise, sbt's loaded 2.8.1 compiler conflicts with scalacl's :'-( (see `getPath` in `TestUtils.scala` on how to get the path for a given runtime class) 
  * write your own plugin component : look at `MyComponent.scala`, then think of registering your component in `ScalaCLPlugin.scala`
  * auto-vectorization :
    # detect `CLArray.apply` "seeds" calls
    # traverse up from these calls until you reach an `IntRange` + `Foreach` loop (see `MiscMatchers.scala`)
    # see if the foreach is convertible to OpenCL (checking captured variables... see convertFunctionToCLFunction
    # output some parallel code : maybe by building a `CLRange`...
  * add runtime + compilation support for images : 
{{{
trait CLImage2D[PixelType] {
  lazy val img: com.nativelibs4java.opencl.CLImage2D
  def apply(x: Int, y: Int): PixelType
  def update(x: Int, y: Int, value: PixelType)
}
}}}
  Also see [http://nativelibs4java.sourceforge.net/javacl/api/current/com/nativelibs4java/opencl/CLImage2D.html CLImage2D] in [http://code.google.com/p/javacl/ JavaCL] (have to be careful reading / writing...)
    * detect image reads/writes in code to say whether it's gonna be used as OpenCL input or output
    * update `OpenCLConverter` to detect calls to `CLImage2D[T].apply` / `update` and replace them by [http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/read_imagei2d.html read_imagei] or [http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/read_imagef2d.html read_imagef] / write_image... See the `case Apply(Select(target, applyName()), List(singleArg)) =>` line
    * implement the apply and update methods with calls to [http://nativelibs4java.sourceforge.net/javacl/api/current/com/nativelibs4java/opencl/CLImage2D.html#read(com.nativelibs4java.opencl.CLQueue, long, long, long, long, long, org.bridj.Pointer, boolean, com.nativelibs4java.opencl.CLEvent...) CLImage2D.read]... and dealing with the different image formats :-S
- swallow functions defined in same compilation unit
- simple lamda lift : forward captured symbols 
- fix side-effects detection
- speedup tests / fix sbt tests
- find a way to debug-break into the plugin in any IDE !

  * other ideas ? (look at [http://scalacl.googlecode.com/svn/wiki/ScalaCL%20Scalathon%20Philadelphia%202011.pdf the slides] :-))